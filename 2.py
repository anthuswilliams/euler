# PROBLEM: Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
#
# 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
#
# By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.


# SOLUTION: The nth term f_n = f_(n-1) + f(n-2) -- in linear algebra
#                   [ f_n ]         =   [ 1 1] * [ f_(n-1) ]
#                   [ f_(n-1)]          [ 1 0] * [ f_(n-2) ]
#                               or
#                       u           =      A   *    v
#
#               The eigenvalues of  A are given by the characteristic polynomial x^2 - x - 1, i.e. x = ( 1 +- sqrt(5))/2
#               So the eigenvectors are given by the matrix S = [ (1 + sqrt(5))/2  (1 - sqrt(5))/2 ]
#                                                               [       1               1          ]
#
#               So the nth term is given by [ f_n ] = S V ^n S^(-1) 
#                                           [ f_(n-1) ] 
#                   where V is the matrix with eigenvalues on the diagonal and 0 elsewhere
#
#               To get the even-valued terms, note that the (1 + 3n)th term is even, hence we sum all S V^(3(k-2)) S^(-1) where S V^(1 + 3(k-2)) S^(-1) <= 4 million
#
#                   
# I believe this solution is O(log n)
import math

# n - the maximum number - only values of f_n which do not exceed this will be included in the sum
# d - the divisor, only numbers which are divisible by d will be included in the sum
def number_crunch(n):
    multiplier = 1
    if n < 0:
        muliplier = -1
    n = abs(n)
    def kth_term(k): # this retrieves the kth term, works for k > 3
                    # important to note -- we consider the sequence as starting with 1,1,2,3, not (for example) 1,2,3,5  hence f_4 = 3
        return int( ( ( (1 + math.sqrt(5)) / 2 )**(k - 1) ) * ( (5 + math.sqrt(5)) / 10 ) + ( ( (1 - math.sqrt(5)) / 2 )**(k - 1) ) * ( (5 - math.sqrt(5)) / 10 ) )
    # noting that f_k < ((1 + sqrt(5))/2)^(k-2), we can approximate the the minimum k at which f_k <= n
    #       get this by log(f_k) < (k -2)*log((1 + sqrt(5))/2), which is true because log(x) is strictly increasing where x > 1
    approx_k = int( math.floor( math.log(n) / ( math.log(1 + math.sqrt(5)) - math.log(2) ) ) ) + 2
    # from there, we brute force it to find the appropriate k
    while kth_term(approx_k) > n:
        approx_k -= 1
    # now, we need only consider even-valued elements of the sequence
    #   since every 3rd element is even, we only need consider k of the form k = 3n
    result = 2 # the 3rd element of the sequence
    i = 1
    while i < approx_k//3:
        i += 1
        result += kth_term(3*i)
    return result

if __name__ == "__main__":
    print(number_crunch(354224848179263111168)) # f_100
    print(number_crunch(4*10**6)) # 4 million
